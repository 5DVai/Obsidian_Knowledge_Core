# Command Output Upload Utility
**Source:** command-line-tools\cli\internal\commands\upload.go  
**Ingestion Date:** 2025-11-28

## Executive Summary
The `upload.go` file provides a utility for uploading command output files to a server within a project management context. This utility is part of a command-line interface (CLI) tool designed to interact with the Reconmap API, a platform for managing security assessments. The primary function of this utility is to facilitate the transfer of output files generated by command executions to a centralized server, ensuring that results are stored and accessible for further analysis and reporting.

The utility encapsulates the logic for reading configuration settings, preparing HTTP requests with multipart form data, and handling authentication tokens. It also includes error handling mechanisms to ensure robust file upload operations. This functionality is critical in environments where automated workflows and data integrity are paramount, such as in enterprise-grade security assessment tools.

## Key Concepts & Principles
- **Configuration Management:** Utilizes shared configuration settings to determine API endpoints.
- **File Handling:** Ensures safe file operations, including checking file existence and proper closure.
- **HTTP Multipart Requests:** Implements multipart form data for file uploads, a common pattern for handling file transfers over HTTP.
- **Error Handling:** Provides comprehensive error messages and status checks to ensure reliable operations.
- **Authentication:** Integrates bearer token authentication for secure API interactions.

## Detailed Technical Analysis

### Configuration and Initialization
The utility begins by reading configuration settings using a shared configuration library. This approach centralizes configuration management, allowing for consistent and maintainable settings across different components of the application.

### File Upload Logic
The core functionality is encapsulated in the `Upload` function, which performs several key operations:
- **File Validation:** Checks if the specified output file exists before proceeding with the upload.
- **Multipart Form Data Construction:** Uses the `multipart.Writer` to construct the HTTP request body, allowing for the inclusion of both file data and additional form fields (e.g., `commandUsageId` and `projectId`).
- **HTTP Request Preparation:** Constructs an HTTP POST request with appropriate headers and authentication tokens, leveraging the `api.NewRmapRequest` and `api.AddBearerToken` functions for standardized request creation.

### Error Handling and Feedback
The utility provides detailed feedback to the user through terminal output, indicating the progress and success of the upload operation. It also includes error handling for common issues such as file not found, session expiration, and network errors.

## Enterprise Q&A Bank

1. **Q:** How does the utility ensure secure file uploads?
   **A:** It uses bearer token authentication to secure API requests, ensuring that only authorized users can upload files.

2. **Q:** What happens if the output file does not exist?
   **A:** The utility returns an error message indicating that the specified file could not be found, preventing further upload attempts.

3. **Q:** How are configuration settings managed?
   **A:** Configuration settings are read from a shared configuration file, promoting consistency and ease of maintenance.

4. **Q:** Can this utility handle uploads for multiple projects?
   **A:** Yes, it supports specifying a `projectId`, allowing uploads to be associated with different projects.

5. **Q:** What feedback does the user receive during the upload process?
   **A:** The utility provides visual feedback using terminal symbols (e.g., yellow dot, green tick) and prints status messages to indicate progress and completion.

## Actionable Takeaways
- Ensure that configuration files are correctly set up and accessible by the utility.
- Validate the existence of output files before attempting uploads to avoid unnecessary errors.
- Use multipart form data for file uploads to handle both file content and additional metadata.
- Implement robust error handling to provide clear feedback and maintain user trust.
- Regularly update authentication tokens to prevent session expiration issues.

---
**Raw Content:**
```go
package commands

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/reconmap/cli/internal/configuration"
	"github.com/reconmap/cli/internal/terminal"
	"github.com/reconmap/shared-lib/pkg/api"
	sharedconfig "github.com/reconmap/shared-lib/pkg/configuration"
	"github.com/reconmap/shared-lib/pkg/models"
)

func UploadResults(projectId int, usage *models.CommandUsage) error {
	if len(strings.TrimSpace(usage.OutputFilename)) == 0 {
		return errors.New("The command has not defined an output filename. Nothing has been uploaded to the server.")
	}

	config, err := sharedconfig.ReadConfig[configuration.Config](configuration.ConfigFileName)
	if err != nil {
		return err
	}
	var remoteURL string = config.ReconmapApiConfig.BaseUri + "/commands/outputs"

	var client *http.Client = &http.Client{}
	err = Upload(client, remoteURL, usage.OutputFilename, usage.ID, projectId)
	return err
}

func Upload(client *http.Client, url string, outputFileName string, usageId int, projectId int) (err error) {

	if _, err := os.Stat(outputFileName); os.IsNotExist(err) {
		return fmt.Errorf("Output file '%s' could not be found", outputFileName)
	}

	file, err := os.Open(filepath.Clean(outputFileName))
	defer func() {
		if err := file.Close(); err != nil {
			fmt.Printf("Error closing file: %s\n", err)
		}
	}()

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile("resultFile", filepath.Base(outputFileName))
	_, err = io.Copy(part, file)

	if err = writer.WriteField("commandUsageId", strconv.Itoa(usageId)); err != nil {
		return
	}
	if projectId != 0 {
		fmt.Println("Project ID is set, uploading to project", projectId)
		if err = writer.WriteField("projectId", strconv.Itoa(projectId)); err != nil {
			return
		}
	} else {
		fmt.Println("Project ID is not set,")
	}

	if err = writer.Close(); err != nil {
		return
	}

	req, err := api.NewRmapRequest("POST", url, body)
	if err != nil {
		return
	}

	err = api.AddBearerToken(req)
	if err != nil {
		return
	}

	req.Header.Set("Content-Type", writer.FormDataContentType())

	terminal.PrintYellowDot()
	fmt.Printf(" Uploading command output '%s' to the server.\n", outputFileName)
	res, err := client.Do(req)
	if err != nil {
		terminal.PrintRedCross()
		fmt.Printf(" Error uploading command output: %s\n", err)
		return
	}

	if res.StatusCode == http.StatusUnauthorized {
		err = fmt.Errorf("your session has expired. Please login again")
	}
	terminal.PrintGreenTick()
	fmt.Printf(" Done\n")

	return
}
```